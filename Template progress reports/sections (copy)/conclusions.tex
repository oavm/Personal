\documentclass[main.tex]{subfiles}

\begin{document}
	
\vspace{20pt}

The conclusions for this project can be divided into several parts. First of all, modeling and system identification proved to be a difficult and time consuming task, due to the fact that while performing them, it is required to decide the moment when a model is good for control. This is related to make the correct choices of identification signals, experiment duration and the initial guesses for the nonlinear least-squares parameter estimation. Using the subspace identification method was considered along the identification process, but discarded because this method is mainly used for system from which it is little known about the inner dynamics of the system.



Implementation of the State-Feedback Pole Placement controller on the real setup brought unforeseen problems with it. As noted before in Section \ref{Encoders} and \ref{sec:Control} Encoder 2 has an offset when it reaches $\pi$. Also the controller was really sensitive to small offsets when it had to be tuned to stabilize the system at $(0,0)$. Both these problems were overcome by implementing an automatized calibration before each experiment. This was done by balancing the pendulum manually or holding it in place on the unstable equilibrium for 2 seconds, and then taking the mean of the outputs and subtracting that from the during the experiment. This way the controller could start each experiment from a new zero point; decreasing its initial control action when the experiment started caused by the offset. \\ 
The deadzone of motor as identified in Section \ref{sec:Deadzone} did create as much problems as anticipated. Linear control was able to get good results. 
The noise in the real setup also caused for a lot of problems, until the Kalman filter was properly tuned. In the beginning it was difficult to differentiate if the bad performance of the closed loop system was due to a poorly tuned Kalman filter or due to a poorly tuned controller. This took some practice and tuning experience to overcome. When the time was taken to properly tune the Kalman filter in the $(\pi,0)$ position, the response of the closed-loop system became much smoother. \\ 
The tuning of the Pole Placement controller was made a lot easier by the scripted computation of the pole locations. This way a requested behaviour could be given, and the required poles would be computed automatically. The stabilization of $(\pi,\pi)$ with the pole placement controller was the first real accomplishment. After that the next hurdle was stabilizing the $(0,0)$ position. This took a few days of tuning both the controller and the Kalman filter. \\
For the $H_{\infty}$ controller, tuning was surprisingly less hard than expected at the $(\pi,\pi)$ position, since the input and performance weights could be deduced by using guidelines set by \cite{Skogestad}. The performance obtained from start with the first design was unexpected, because the experience using this framework was limited. Moreover, the controller allowed the system to be able to track a sine signal and reject disturbances. 
A great part of the success of the initial controller, could have been due to the use of the filtered estimates and not the direct output of the system. Since model uncertainty was not introduced to the design process and no D-K iterations were performed, robustness could not be ensured by using the output signal directly Nevertheless, when applying the $H_\infty$ for the upright position the results were not as successful as for the previous position. 

There could be two main reasons for this result. First of all the implementation of the $H_\infty$ controller on discrete time just by using \mcode{c2d}. By doing some research there are specific methods and routines in MATLAB\textsuperscript{\textregistered} for $H_\infty$ in discrete time(such as \mcode{sdhinfsyn}). Secondly, having a refined function for the input weight could have influenced the performance, because the size of the input differs greatly if the system has small and high frequent oscillations. A possible choice could have been a transfer function with one double zero at low frequencies and  one double pole at high frequencies. The position of the poles a zeroes should be based on the closed-loop bandwidth. A possible subsequent step could be obtaining the closed-loop bandwidth of the system with the pole-placement controller and provide a multivariable design using the $H_\infty$ controller.

Finally, overall the control of the Rotational Inverted Pendulum proved to be a challenging task because of the involved dynamics of the system, the filtering task and the controller design and tuning. This project gave great insight about the problems regarding real life implementation. Elements that may be seen as simple during the process (such as the direction of the angles) can cause great delays in the control design process. This specific setup, is also hard to control at the upright position because from the theoretical point of view, both links are on an unstable equilibrium.



\end{document}
